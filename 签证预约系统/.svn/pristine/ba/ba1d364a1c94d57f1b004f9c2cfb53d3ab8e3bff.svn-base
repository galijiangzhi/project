#!/usr/bin/env python
# coding=utf-8
class 账号类(object):
    def __init__(self):
        self.最后使用时间 = None

    def login(self):
        网站login
        main页面检查
        移动到爬数据页面
        self.最后使用时间 = now

class 日期生产员(账号类):
    def work(self):
        if 日期生产员使用超过N小时 or 日期生产员还没有确定
            self.load一个闲置日期生产员()

        if 日期生产员还未login
            self.login()

        # 注意:下面这一段（爬到日期数据后 → 消费者完成预约）
        #   对实时性的要求极高。能节省0.1秒就节省0.1秒
        数据库.待更新内容.清空
        最早日期列表(城市,最早日期) = self.爬日期数据()
        for 爬到的日期数据:
            需要本日期的消费者列表 = 哪些消费者需要约这个日期(城市,最早日期)
            if 有消费者需要:
                可用时分 = 时分生产管理员.取得可约的时间(城市,最早日期)
                对 所有需要本日期的消费者 循环:
                    消费者.预约(城市，最早日期，可用时分)
        数据库.待更新内容.保存到数据库

    def load一个闲置生产员(self):
        从数据库提取生产员IVR信息 TOP 1
            签证类型相同 = 系统配置信息.指定签证类型
            签证费缴纳状态 = 未缴费
        排序
            时分生产历史信息.本操作时间戳 倒序

        数据库.更新日期生产员最后使用时间()


    def 爬日期数据(self):
        数据库.增加一个待更新内容.更新日期生产员最后使用时间()
        在网站上爬取数据
        数据库.增加一个待更新内容.插入日期生产历史信息()


class 时分生产员(账号类):
    def __init__(self):

    def 激活(self):
        if 时分生产员使用超过N小时 or 时分生产员还没有确定:
            self.load一个闲置生产员()

        if 时分生产员还未login:
            self.login()

        if 时分生产员使用超过M小时(sessionTimeOut时间):
            self.避免timeout()

    def 取得可约的时间(self, 城市,最早日期):
        数据库.增加一个待更新内容.更新时分生产员最后使用时间()
        self.爬取网站的时分(城市,最早日期)
        数据库.增加一个待更新内容.插入时分生产历史信息()

    def load一个闲置生产员(self):
        从数据库提取生产员IVR信息 TOP 1
            签证类型相同 = 系统配置信息.指定签证类型
            签证费缴纳状态 = 已缴费
            是否允许做时分生产员 = 允许
            是否已经过期 = 未过期
        排序
            时分生产历史信息.本操作时间戳 倒序

        数据库.更新时分生产员最后使用时间()


class 时分生产管理员():
    def __init__(self):
        self.时分生产员List = 时分生产员[系统配置.同时在线时分生产员人数] # 系统配置.同时在线时分生产员人数 1~20

    def 启动(self):
        for [0, 系统配置.同时在线时分生产员人数]
            开启线程(间隔N小时, 时分生产员[i].激活)

    def 取得可约的时间(self,城市,最早日期):
        从最后被使用的生产员开始，取得后面3个时分生产员 # 这个3在系统配置里面定义
        # todo: 这个技术可行？
        多线程启动 3个时分生产员.取得可约的时间()  # 同时启动目的是为了避免某个生产员取数据失败
        哪个时分生产员最先获得可约的时分，就用哪个时分

class 日期生产管理员():
    def __init__(self):
        self.日期生产员List = 日期生产员[系统配置.同时在线日期生产员人数]  # 系统配置.同时在线日期生产员人数 固定为60

    def 启动(self):
        循环启动60个日期生产员i
            开启线程(0时0分i秒开始运行，每隔5分启动一次, 日期生产员[i].work)

class 生产管理员():
    def __init__(self):
        self.时分生产管理员 = 时分生产管理员()
        self.日期生产管理员 = 日期生产管理员()

    def 启动(self):
        时分生产管理员().启动()
        日期生产管理员().启动()


class 系统配置信息():
    def __init__(self):
        self.加载配置文件信息()
        self.加载数据库系统信息()
        开线程 每隔N分钟 self.加载数据库系统信息()

    def 加载配置文件信息(self):
        self.db连接信息, self.本系统需要处理的账号分类... = 配置文件【config.yaml】取得的信息
        global dbcon = 连接数据库()

    def 加载数据库系统信息(self):
        self.重新login间隔, self.大使馆网站timeout时间... = 数据库【系统配置表】取得的信息，每隔5分钟更新一下


def 读取订单信息,循环返回一个订单防止重复():
    return 账号ID，初始预约状态，初始预约城市cd，
            初始预约日期，订单说明，最终预约状态，
            最终预约城市cd，最终预约日期，最终预约时分，
            是否允许做时分生产员，创建时间，更新时间

def 记录登陆失败(id,time,账号类型)
    将登陆失败信息记录到数据库
def 判断信息是否有用(国家，日期):
    list1=[]
    进入数据库查看有没有需要该条信息的订单 并且将订单记录到list1
    return 有/没有 list1

if name=='__main__':
    global 系统配置信息 = 系统配置信息()
    订单管理员().启动()
    生产管理员().启动()
