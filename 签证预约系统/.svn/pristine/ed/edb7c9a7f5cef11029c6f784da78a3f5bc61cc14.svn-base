#!/usr/bin/env python
# coding=utf-8
class 账号类(object):
    def 伪支付费用()：
        return 国家 日期


class 日期生产员(账号类)：
    def 日期生产员工作():
        登陆状态=post 登录#给服务器发信息 返回成功或者失败
        if 登陆状态==成功:
            开一条线程 运行self.work
        else：
            记录登陆失败（self.id,time.(),self.type)

    def work(self):
        日期生产元刷新数据间隔 = global 日期生产元刷新数据间隔
        while True:
            国家，日期=self.伪支付费用()
            nb，list1=判断信息是否有用(国家，日期)
            if nb=有:
                提取list1里的账号类型
                开线程 运行 安排时分生产元进行查询（list1，日期，时间）
            # todo:不能用sleep。
            #  如果0:01秒爬过数据的话，下一次我们希望这个生产员是5:01秒爬数据。
            #  sleep无法保证下一次是5:01
            sleep(日期生产元刷新数据间隔)

class 时分生产员(账号类)：

def 安排时分生产元进行查询

# todo:我把这个大改了一下
class 系统配置信息():
    def __init__(self):
        self.加载配置文件信息()
        self.加载数据库系统信息()
        开线程 每隔N分钟 self.加载数据库系统信息()

    def 加载配置文件信息(self):
        self.db连接信息, self.本系统需要处理的账号分类... = 配置文件【config.yaml】取得的信息
        global dbcon = 连接数据库()

    def 加载数据库系统信息(self):
        self.重新login间隔, self.大使馆网站timeout时间... = 数据库【系统配置表】取得的信息，每隔5分钟更新一下

def 读取订单信息,循环返回一个订单防止重复():
    return 账号ID，初始预约状态，初始预约城市cd，
            初始预约日期，订单说明，最终预约状态，
            最终预约城市cd，最终预约日期，最终预约时分，
            是否允许做时分生产员，创建时间，更新时间

def 启动日期生产员():
    循环 in [0, 60]

    # todo:得讨论一下
    # todo:根据系统配置，启动生产员。并且
    #  只启动60个，以保证5分钟时间点的时候，每秒有一个生产员爬一次数据
    #  生产员需要和配置文件里面的【本系统需要处理的账号分类】相同
    #  某个生产员启动了N小时后，需要换一个生产员（最久前被闲置的生产员）
    循环 in 账号生产员库
        使用id查询账号密码
        为每一个日期生产员开启一个线程（内容为：日期生产元工作）

def 记录登陆失败(id,time,账号类型)
    将登陆失败信息记录到数据库
def 判断信息是否有用(国家，日期):
    list1=[]
    进入数据库查看有没有需要该条信息的订单 并且将订单记录到list1
    return 有/没有 list1

if name=='__main__':
    global 系统配置信息 = 系统配置信息()
    启动日期生产员()
