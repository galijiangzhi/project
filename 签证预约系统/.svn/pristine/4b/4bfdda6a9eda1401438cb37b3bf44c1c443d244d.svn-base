#!/usr/bin/env python
# coding=utf-8
class 账号类(object):
    def __init__(self):
        self.最后使用时间 = None

    def login(self):
        网站login
        main页面检查
        移动到爬数据页面
        self.最后使用时间 = now

class 日期生产员(账号类):
    def work(self):
        if 日期生产员使用超过N小时 or 日期生产员还没有确定
            self.load一个闲置日期生产员()

        if 日期生产员还未login
            self.login()

        # 注意:下面这一段（爬到日期数据后 → 消费者完成预约）
        #   对实时性的要求极高。能节省0.1秒就节省0.1秒
        数据库.待更新内容.清空
        最早日期列表(城市,最早日期) = self.爬日期数据()
        for 爬到的日期数据:
            需要本日期的消费者列表 = 哪些消费者需要约这个日期(城市,最早日期)
            if 有消费者需要:
                可用时分 = 时分生产管理员.取得可约的时间(城市,最早日期)
                对 所有需要本日期的消费者 循环:
                    消费者.预约(城市，最早日期，可用时分)
        数据库.待更新内容.保存到数据库

    def load一个闲置生产员(self):
        从数据库提取TOP1生产员IVR信息
        签证类型相同 = 系统配置信息.指定签证类型
        签证费缴纳状态 = 未缴费
        排序: 日期生产员.最后操作时间 倒序

        数据库.更新日期生产员最后使用时间()

    def 爬日期数据(self):
        数据库.增加一个待更新内容.更新日期生产员最后使用时间()
        在网站上爬取数据
        数据库.增加一个待更新内容.插入日期生产历史信息()


class 时分生产员(账号类):
    def __init__(self):

    def 激活(self):
        if 时分生产员使用超过N小时 or 时分生产员还没有确定:
            self.load一个闲置生产员()

        if 时分生产员还未login:
            self.login()

        if 时分生产员使用超过M小时(sessionTimeOut时间):
            self.避免timeout()

    def 取得可约的时间(self, 城市,最早日期):
        数据库.增加一个待更新内容.更新时分生产员最后使用时间()
        self.爬取网站的时分(城市,最早日期)
        数据库.增加一个待更新内容.插入时分生产历史信息()

    def load一个闲置生产员(self):
        从数据库提取生产员IVR信息 TOP 1
            签证类型相同 = 系统配置信息.指定签证类型
            签证费缴纳状态 = 已缴费
            是否允许做时分生产员 = 允许
            是否已经过期 = 未过期
        排序
            时分生产历史信息.本操作时间戳 倒序

        数据库.更新时分生产员最后使用时间()


class 时分生产管理员():
    def __init__(self):
        self.时分生产员List = 时分生产员[系统配置.同时在线时分生产员人数] # 系统配置.同时在线时分生产员人数 1~20

    def 启动(self):
        for [0, 系统配置.同时在线时分生产员人数]
            开启线程(间隔N小时, 时分生产员[i].激活)

    def 取得可约的时间(self,城市,最早日期):
        从最后被使用的生产员开始，取得后面3个时分生产员 # 这个3在系统配置里面定义
        # todo: 这个技术可行？
        多线程启动 3个时分生产员.取得可约的时间()  # 同时启动目的是为了避免某个生产员取数据失败
        哪个时分生产员最先获得可约的时分，就用哪个时分

class 日期生产管理员():
    def __init__(self):
        self.日期生产员List = 日期生产员[系统配置.同时在线日期生产员人数]  # 系统配置.同时在线日期生产员人数 固定为60

    def 启动(self):
        循环启动60个日期生产员i
            开启线程(0时0分i秒开始运行，每隔5分启动一次, 日期生产员[i].work)

class 生产管理员():
    def __init__(self):
        self.时分生产管理员 = 时分生产管理员()
        self.日期生产管理员 = 日期生产管理员()

    def 启动(self):
        时分生产管理员().启动()
        日期生产管理员().启动()


class 系统配置信息():
    def __init__(self):
        self.加载配置文件信息()
        self.加载数据库系统信息()
        开线程 每隔N分钟 self.加载数据库系统信息()

    def 加载配置文件信息(self):
        self.db连接信息, self.本系统需要处理的账号分类... = 配置文件【config.yaml】取得的信息
        global dbcon = 连接数据库()

    def 加载数据库系统信息(self):
        self.重新login间隔, self.大使馆网站timeout时间... = 数据库【系统配置表】取得的信息，每隔5分钟更新一下


def 读取订单信息,循环返回一个订单防止重复():
    return 账号ID，初始预约状态，初始预约城市cd，
            初始预约日期，订单说明，最终预约状态，
            最终预约城市cd，最终预约日期，最终预约时分，
            是否允许做时分生产员，创建时间，更新时间

def 记录登陆失败(id,time,账号类型)
    将登陆失败信息记录到数据库
def 判断信息是否有用(国家，日期):
    list1=[]
    进入数据库查看有没有需要该条信息的订单 并且将订单记录到list1
    return 有/没有 list1

class 客户():
    def __init__(self):
        self.账号信息
        self.预约期间信息

    def 激活(self):
        if 客户使用超过N小时(最大可以呆在网站里面的时间):
            self.logout()
            self.login()

        if 客户还未login:
            self.login()

        if 客户使用超过M小时(login后不做任何事，sessionTimeOut时间):
            self.避免timeout()



class 客户管理员():
    def __init__(self):
    def 启动(self):
        # todo: 待预约的客户，线程应该怎么管理比较好？现在的需求是这样的
        #  关于客户的启动和停止
        #    系统刚刚启动时候，所有客户load进系统，并login进网站
        #    每个客户运行一段时间后，都需要做一下激活，避免客户长期处于login状态，网站超时
        #    系统运行过程中，不断有新的客户可能加进来
        #    客户约好位置后就要从本系统去掉
        #    客户也可能被外界临时中止预约（数据库的这个客户的信息改成暂停）
        #  另外，为了日期生产员能最快速度判断查找到的日期有没有人需要约
        #  所有客户的期望都需要在一个key map里面保存[key=日期, value = 相关客户列表[]]
        #    [11/1,[客户A，客户B]], [11/2,[客户A]], [11/3,[客户B]]]
        #    代表 客户A可以接受11/1，11/2的面试， 客户B接受11/1和11/3， 其他日期没有任何客户需要
        #  所以，客户启动和停止还需要维护这个key map
        数据库.查找所有待预约的订单
        for 针对每个待预约订单
            开启线程(启动一次, self.循环启动所有客户)



if name=='__main__':
    global 系统配置信息 = 系统配置信息()
    订单管理员().启动()
    生产管理员().启动()
